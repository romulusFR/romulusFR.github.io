---
date: Décembre 2022
title: Projet CNRT Mines et Territoire
author: THION Romuald, UNC
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    theme: united
    highlight: tango
    css: custom.css

---

# Evolution du niveau d'équipement des ménages NC et l'influence de la mine.

Cette étude porte sur le Niveau d'Equipement des Ménages (**NEM**) sur les Bases Individuelles (**BI**) et les Bases Logements (**BL**) du Recensement de la Population (**RP**) de Nouvelle-Calédonie (NC) sur les années 2009, 2014 et 2019.
Cette étude est réalisé par THION Romuald, maître de conférences en informatique à l'UNC, dans les locaux de l'ISEE dans le cadre du projet CNRT _Mine et Territoires_ (**M&T**).

## Sources de données

```{r init-libraries, include=FALSE}
# installer les lib suivantes avec install.packages() si besoin
library(tidyverse)
library(foreign)
library(sf)
library(FactoMineR)
library(MatchIt)

set.seed(2022)


`%notin%` <- Negate(`%in%`)

# options de rendu knitr
knitr::opts_chunk$set(
  echo = FALSE,
  warning = FALSE,
  message = FALSE,
  fig.fullwidth = TRUE,
  fig.height = 9,
  fig.width = 16
)

# options de rendu générales dont figures
options(
  width = 144,
  digits = 3
)

theme_set(
  theme_light() %+replace%
    theme(
      panel.border = element_blank(),
      axis.text.x = element_text(angle = 90),
      legend.position = "right",
    )
)
```

Les sources de données suivantes sont utilisées dans cette étude :

- `src-iris/` : le shapefile des IRIS UNC09-14-19 créé par l'ISEE pour le projet M&T.
- `src-communes/` : les limites administratives terrestres (BDADMIN-NC) des communes, [source](<https://georep-dtsi-sgt.opendata.arcgis.com/maps/limites-administratives-terrestres-1/about>). Le shapefile est chargé en SQL et enrichi avec l'information du type de site retenu dans le projet M&T (_centre_, _usine/métallurgique_ ou _témoin_). Un export CSV `communes.csv` permet d'avoir les noms correctement encodés.
- `src-desserte/` : le calcul à partir de la BDROUTE-NC de la durée minimale/moyenne/médiane maximale à chacun des sites miniers, voir rapport technique consacré dans les livrables du projet. Les données sont ré-exportées dans le fichier `duree-iris.csv` dans un format utilisable facilement en R.
- `src-rp/` : les BI et BL des RP 2009, 2014 et 2019 accompagnés de leurs dictionnaires de données fournis par l'ISEE. La conversion du format `dbf` dans le format `csv` est réalisée par le script [`export_dbf_to_csv.R`](export_dbf_to_csv.R) à exécuter une fois pour toutes.


On charge le dictionnaire des communes et des IRIS pour avoir leurs noms correctement orthographiés.

```{r load-communes, cache=TRUE}
communes_csv <- read_csv2("src-communes/communes.csv") %>% column_to_rownames("CODE_COM")
iris_csv <- read_csv2("src-iris/iris.csv") %>% select(IRIS, LIB_IRIS)

# communes du Grand Nouméa : NOUMEA (18), PAITA (21), MONT DORE (17), DUMBEA (05)
grand_noumea <- c("05", "17", "18", "21")
```

Ensuite on charge les BL des trois années, en ne gardant :

- que les logements qui sont des **résidences principales** (`CATL == 1`),
- que les ménages qui sont **hors du Grand Nouméa** (`NC %notin% grand_noumea`).

On remarque de filtrer hors du GN a un effet très limité sur les évolutions (sauf en valeur absolue de variation des écart-types) mais améliore la qualité des regressions.

On crée également la clef de jointure `IDLOG` entre la BI et la BL comme la concaténation des variables suivantes, dans l'ordre :

- `NC` : numéro de la commune (de 01 à 33),
- `DIST` : code ilot / district. C'est l'unité géographique de référence de l'ISEE. On utilisera plutôt la commune et un IRIS intermédiaire entre commune et îlot créé pour le projet, appelé `IRIS` ou `IRISUNC`
- `RADR` : rang de la construction, rang de l'adresse. 
- `RLOG` : rang de logement.

Si les questionnaires des RP 2009, 2014 et 2019 sont très similaires, certaines modalités changent néanmoins, dont notamment dans la BL 2019 :

- la variable `BATI` en 2019, les anciennes modalités 2009 et 2009 sont disponibles dans la variable `TYPC14`.
- la variable `DIPLM` en 2019, les anciennes modalités 2009 et 2009 sont disponibles dans la variable `DIPLM14`.

```{r load-bl, cache=TRUE}
bl09_r <- read_csv2("./src-rp/BL2009.csv") %>%
  filter(CATL == 1) %>%
  filter(NC %notin% grand_noumea) %>%
  mutate(
    # on crée la clef de jointure entre BL et BI
    IDLOG = paste(NC, DIST, RADR, RLOG, sep = "-")
  )

bl14_r <- read_csv2("./src-rp/BL2014.csv") %>%
  filter(CATL == 1) %>%
  filter(NC %notin% grand_noumea) %>%
  mutate(
    # on crée la clef de jointure entre BL et BI
    IDLOG = paste(NC, DIST, RADR, RLOG, sep = "-")
  )

bl19_r <- read_csv2("./src-rp/BL2019.csv") %>%
  filter(CATL == 1) %>%
  filter(NC %notin% grand_noumea) %>%
  mutate(
    # on transforme les modalités BATI et DIPLM de 2019 pour reprendre celles de 2009/2014
    # afin que les années soient comparables
    BATI = TYPC14,
    DIPLM = DIPLM14,
    # on crée la clef de jointure entre BL et BI
    IDLOG = paste(NC, DIST, RADR, RLOG, sep = "-")
  )

# un erreur corrigée manuellement dans le CSV
# ligne 54501, colonne 71 (année), la valeur 198? a été remplacée par 1985.
# 1 54501    71 a double 198?
```

On note qu'à ce stade, on ne se sert pas encore des BI.
In fine, les trois BL contiennent :

-  `r (nrow(bl09_r))` logements d'intérêt en 2009 décrits par `r ncol(bl09_r)` variables,
-  `r (nrow(bl14_r))` logements d'intérêt en 2014 décrits par `r ncol(bl14_r)` variables,
-  `r (nrow(bl19_r))` logements d'intérêt en 2019 décrits par `r ncol(bl19_r)` variables.

```{r load-bl-sizes, include=FALSE}
for (base in list(bl09_r, bl14_r, bl19_r)) {
  print(paste(nrow(base), "logements,", ncol(base), "variables"))
}
```



## Calcul du NEM

On reprend la méthodologie générale des études socio-énonomiques précédemment réalisées dans le volet A du projet M&T dans les stages d'Elise, Alban et Heloise.
Ces travaux s'appuyent entres autres sur un indicateur de _niveau d'équipement des ménages_, abrégé **NEM**, construit à partir des variables d'équipements disponibles dans la BL.

### Codage des modalités

La première étape est le traitement des **14 variables catégorielles d'équipement des ménages**.
On doit adapter le codage utilisés précédement pour les RP 2009 et 2014 :

- les variables `TMOB`, `ORDI` ne sont plus présentes dans la BL 2019.
- certaines modalités comme `ELEC` on changé en 2019.
- la variable `MAL` présente sur les 3 RP a été ajoutée.
- le codage des variables `VOIT`, `BATO`, `DEROU` a été modifié
  - il a été binarisé, pour le rendre homogène avec les autres, alors qu'il était précédement codé sur 4 valeurs,
  - on s'appuie sur le nombre d'actifs du logement (`INPAM`) et plus le nombre de personnes majeurs, ce qui évite une jointure avec la BI, 

Il y a un questionnement général sur **l'influence du codage sur les résultats d'analyses** et la validité des conclusions _si on adopte un codage similaire mais différent_.

Le codage est encapsulé dans la fonction `codage_modalites_bl` qui va créer un nouveau _dataframe_
Cette fonction transforme 14 variables catégorielles d'équipement en variables binaires.
Sauf précision, il n'y a que deux modalités _1 : équipé_ et  _2 : non équipé_ pour les 14 variables suivantes qui sont agrégés dans le NEM :

- `ELEC`: mode principal d'éclairage. (RP09/14 : 1 = réseau général, 3 = panneaux. RP19 : 1 = raccordé, 2 = non). Par cohérence entre années, on ne garde que la modalité 1;
- `EAU` : alimentation principale en eau du logement. (RP09/14/19 : 1 = eau courante);
- `BATI` : type de logement, 1 ssi le type est _maison_ (1) ou _appartement_ (2), les autres valeurs valant 0;
- `BAIN` : baignoire ou douche (variables `IS` dans les données 2009 et 2014 de P. Rivoilant);
- `WC` : équipement en WC;
- `MAL` :  machine à laver;
- `REFRI` : réfrigérateur;
- `CLIM` :  équipement du logement en climatisation;
- `CHOS` : équipement du logement en chauffe-eau solaire;
- `TFIXE` : téléphone fixe;
- `INTER` : accès internet;
- `VOIT` : nombre de voitures, 1 ssi le nombre de véhicules est supérieur ou égal au nombre d'actifs;
- `BATO` : nombre de bateaux, 1 ssi le nombre de véhicules est supérieur ou égal au nombre d'actifs;
- `DEROU` : nombre de deux-roues motorisés, 1 ssi le nombre de véhicules est supérieur ou égal au nombre d'actifs.


```{r codage-modalite-bl-funct, echo=TRUE}
codage_modalites_bl <- function(src) {
  # on garde les variables suppl d'intérêt
  base <- src %>%
    select(IDLOG, IRISUNC, NC, PROV, CS8M, DIPLM, AGERM)
  # on construit les 14 variables binaires
  base$ELEC <- as.numeric(src$ELEC == 1)
  base$EAU <- as.numeric(src$EAU == 1)
  base$BATI <- as.numeric(src$BATI %in% c(1, 2))
  base$BAIN <- as.numeric(src$BAIN == 1)
  base$WC <- as.numeric(src$WC == 1)
  base$MAL <- as.numeric(src$MAL == 1)
  base$REFRI <- as.numeric(src$REFRI == 1)
  base$CLIM <- as.numeric(src$CLIM == 1)
  base$CHOS <- as.numeric(src$CHOS == 1)
  base$TFIXE <- as.numeric(src$TFIXE == 1)
  base$INTER <- as.numeric(src$INTER == 1)
  base$VOIT <- as.numeric(src$INPAM <= src$VOIT)
  base$BATO <- as.numeric(src$INPAM <= src$BATO)
  base$DEROU <- as.numeric(src$INPAM <= src$DEROU)
  return(base)
}
```

On applique cette transformation et on ne garde que le sous-ensemble des 14 variables d'équipement d'intérêt et des cofacteurs d'analyse, soit :

- le code d'IRIS (variable `IRISUNC`),
- le numéro de commune (variable `NC`)
- la province (variable `PROV`)
- la CSP sur 8 postes de la personne de référence du ménage (variable `CS8M`)
- le diplôme de la personne de référence du ménage (variable `DIPLM`)
- l'age révolu de la personne de référence du ménage (variable `AGERM`)
- on garde aussi `IDLOG` pour la jointure avec la BI.


```{r codage-modalite-bl, cache=TRUE}
bl09 <- codage_modalites_bl(bl09_r)
bl14 <- codage_modalites_bl(bl14_r)
bl19 <- codage_modalites_bl(bl19_r)
```

### Calcul des poids du NEM

On va maintenant calculer le NEM avec le poids de chacune des variables d'équipement grâce aux 5 premières dimensions d'une ACP.
Ce calcul est refait pour chacun des RP 2009, 2014 et 2019.
Pour le chargement dans QGIS, on crée _manuellement_ un fichier `.csvt` éponyme qui contient les types des colonnes.

```{r compute-nem-weights}
# nombre de dimensions de la projection qu'on garde pour le calcul des poids
n_dim <- 5
get_weights <- function(base) {
  res <- base %>%
    select(-IRISUNC, -NC, -PROV, -CS8M, -DIPLM, -AGERM, -IDLOG) %>%
    PCA(scale.unit = TRUE, graph = FALSE, ncp = n_dim)
  var_n_dim <- sum(res$eig[1:n_dim, 2])
  weights <- res$var$contrib[, 1:n_dim] %*% res$eig[1:n_dim, 2] / var_n_dim
  return(weights)
}

weights <- list(bl09, bl14, bl19) %>%
  sapply(get_weights) %>%
  data.frame()
colnames(weights) <- c("Y2009", "Y2014", "Y2019")
row.names(weights) <- c("ELEC", "EAU", "BATI", "BAIN", "WC", "MAL", "REFRI", "CLIM", "CHOS", "TFIXE", "INTER", "VOIT", "BATO", "DEROU")
write.csv2(weights, "output/nem_weights.csv", na = "", fileEncoding = "UTF-8", row.names = TRUE)
```

On a des _variation substantielles_ des coefficients selon le codage choisi avec ka fonction `codage_modalites_bl`.
On affiche ci-dessous le résultat enregistré dans le fichier  `output/nem_weights.csv`.

```{r compute-nem-weights-show}
weights
```

On conforte certaine intuitions via l'évolutions des poids calculés via la PCA, comme l'influence du raccordement à l'eau qui diminue dans le temps et est une des plus faible.
Maintenant on enrichit les _dataframes_ `bl09`, `bl14` et `bl19` avec les valeurs du NEM (variable `NEM`) et les valeurs en base 100 (variable `NEM100`) sur _toute la Nouvelle-Calédonie_.

```{r compute-nem-weights-base-100}
bl09$NEM <- rowSums(select(bl09, -IDLOG, -IRISUNC, -NC, -PROV, -CS8M, -DIPLM, -AGERM) * weights[, "Y2009"])
bl09$NEM100 <- (100 * bl09$NEM) / mean(bl09$NEM)

bl14$NEM <- rowSums(select(bl14, -IDLOG, -IRISUNC, -NC, -PROV, -CS8M, -DIPLM, -AGERM) * weights[, "Y2014"])
bl14$NEM100 <- (100 * bl14$NEM) / mean(bl14$NEM)

bl19$NEM <- rowSums(select(bl19, -IDLOG, -IRISUNC, -NC, -PROV, -CS8M, -DIPLM, -AGERM) * weights[, "Y2014"])
bl19$NEM100 <- (100 * bl19$NEM) / mean(bl19$NEM)
```

### Agrégation du NEM par IRIS

On crée un _dataframe_ avec les valeurs agrégées du NEM par IRIS, on donne ici 7 indicateurs pour chaque IRIS et chaque année :

- le **nombre** de logements,
- la **somme**, la **moyenne** et l'**écart-type** du NEM,
- la **somme**, la **moyenne** et l'**écart-type** du NEM base 100 NC,

```{r compute-nem-by-iris}
group_by_iris <- function(base) {
  iris <- base %>%
    group_by(IRISUNC) %>%
    summarise(
      COUNT = n(),
      NEM_SUM = sum(NEM),
      NEM_MEAN = mean(NEM),
      NEM_SD = sd(NEM),
      NEM100_SUM = sum(NEM100),
      NEM100_MEAN = mean(NEM100),
      NEM100_SD = sd(NEM100)
    )
  return(iris)
}
iris09 <- group_by_iris(bl09)
iris14 <- group_by_iris(bl14)
iris19 <- group_by_iris(bl19)
```

On fait la jointure en post-fixant les années et on exporte le tout dans le fichier `output/nem_iris.cs` avec son compagnon `.csvt` qui contient les types (pour QGIS).
On obtient un fichier résultat comme suit avec 22 colonnes (3 années x 7 attributs plus le code IRIS) qui constitue _le matériel de base pour la suite de l'étude_.

```{r join-nem-by-iris}

nem_iris <- (iris09 %>%
  full_join(iris14, by = "IRISUNC", suffix = c("_09", ""))) %>%
  full_join(iris19, by = "IRISUNC", suffix = c("_14", "_19"))

write.csv2(nem_iris, "output/nem_iris.csv", na = "", fileEncoding = "UTF-8", row.names = FALSE)
nem_iris
```


## Contributions des variables du NEM

Dans cette section, on va vérifier la validité de l'indicateur NEM en le comparant aux co-facteurs socio-énconomiques des individus (soit les personnes de référence des ménages, soient les individus de la BI).

### Correlations intervariables

On va aggréger sur les IRIS et ensuite afficher le _corrélogramme_ des 14 variables.

```{r bl-corr-variables}
df_corr_bl <- bl19 %>%
  select(-IDLOG, -PROV, -CS8M, -DIPLM, -AGERM, -starts_with("NEM")) %>%
  group_by(IRISUNC) %>%
  summarise_if(
    is.numeric,
    mean
  ) %>%
  column_to_rownames("IRISUNC")

# corr_cols <- factor(rownames(df_corr_bl) %>% str_sub(1, 2))

corr_cols <- bl19 %>%
  count(IRISUNC, PROV) %>%
  arrange(IRISUNC, desc(n)) %>%
  group_by(IRISUNC) %>%
  summarise(PROV = first(PROV)) %>%
  pull(PROV) %>%
  factor()


panel_cor <- function(x, y, digits = 2, prefix = "", cex.cor, ...) {
  par(usr = c(0, 1, 0, 1))
  r <- abs(cor(x, y))
  txt <- format(c(r, 0.123456789), digits = digits)[1]
  txt <- paste0(prefix, txt)
  if (missing(cex.cor)) cex.cor <- 0.8 / strwidth(txt)
  text(0.5, 0.5, txt, cex = cex.cor * r)
}

panel_hist <- function(x, ...) {
  usr <- par("usr")
  par(usr = c(usr[1:2], 0, 1.5))
  h <- hist(x, plot = FALSE)
  breaks <- h$breaks
  nB <- length(breaks)
  y <- h$counts
  y <- y / max(y)
  rect(breaks[-nB], 0, breaks[-1], y, col = "cyan", ...)
}

write.csv2(df_corr_bl, "output/vars_iris.csv", na = "", fileEncoding = "UTF-8", row.names = FALSE)

pairs(
  df_corr_bl,
  main = "Corrélations entre variables du NEM, colorisé par province (R = Iles, V = Nord, B = Sud)",
  diag.panel = panel_hist,
  upper.panel = panel_cor,
  bg = rainbow(3)[corr_cols],
  pch = 21,
)
```

On apprécie ici les fortes corrélations dans les attributs :

- dans les équipements de base :
  - `WC` et `BAIN`
  - `MAL` et `FRIGO` avec `ELEC`
- dans les équipements supérieurs :
  - très forte entre `CLIM`, `TFIXE` et `INTER` puis `CHOS` dans un second temps
- dans la mobilité :
  - entre `BATO` et `DEROU`
  
A l'inverse, on voit l'indépendance de `VOIT`.

### ACP de l'équipement des ménages par commune

On fait une analyse PCA directement sur les 14 variables d'équipement qui constituent le NEM sur la BL 2019, qu'on agrège par commune pour que le graphe soit plus lisible.

```{r bl-communes-variables}
df_communes <- bl19 %>%
  select(-IDLOG, -IRISUNC, -PROV, -CS8M, -DIPLM, -AGERM) %>%
  group_by(NC) %>%
  summarise(
    across(everything(), mean),
    COUNT = n(),
  ) %>%
  merge(communes_csv, by.x = "NC", by.y = 0) %>%
  column_to_rownames("NOM_COMMUNE") %>%
  select(-NC, -TYPE)

write.csv2(df_communes, "output/nem_communes.csv", na = "", fileEncoding = "UTF-8", row.names = TRUE)
df_communes
```

On remarque la position de Pouembout, Koné et Koumac à droite du premier axe et accompagnés des communes de la côte ouest de la NC.
Les communes de la province des îles, de la côte est et du Nord sont au contraire plutôt à gauche.
Ces deux premières dimensions capturent respectivement 60.1% et 11.6% de la variance.
Pour le NEM on utilise les 5 premières dimensions qui capturent au total 91.3% de la variance.
Si on ajoute le Grand Nouméa dans le calcul du NEM, ses communes se trouveraient à droite, sans surprise.

```{r bl-communes-pca}
pca_communes <- PCA(df_communes %>% select(-NEM, -NEM100, -COUNT), graph = FALSE)
plot(pca_communes)
```

On affiche le résumé de l'analyse avec les contributions de toutes les communes et toutes les variables d'équipement.

```{r bl-communes-pca-summary, warning=F}
summary(pca_communes, nbelements = Inf)
```

### AFC de l'équipement des ménages par commune

Avec _l'Analyse Factorielle des Correspondances_ (AFC) on va pouvoir representer graphiquement les communes et les 14 variables dans un même espace.
On distingue _sur les 2 axes principaux_ les groupes de variables suivants, qui sont aussi visibles sur le cercle des correspondances de l'ACP (non représenté) :

- `CLIM`, `TFIXE`, `INTER` et `CHOS` qui donnent du poids au premier axe (et qui seraient proches du Grand Nouméa si on l'incluait),
- un groupe `REFRI`, `ELEC`, `BAIN`, `WC`, `EAU` et `BATI` proches du profil moyen, `MAL` s'échappant un peu,  `VOIT` est peu discriminant et proche de ce groupe,
- le transport avec `DEROU` et `BATO` qui contribuent largement au 2ème axe. 

```{r bl-communes-ca}
ca_commune <- CA(df_communes %>% select(-NEM, -NEM100, -COUNT), graph = FALSE)
plot(ca_commune)
```

On affiche le résumé de l'analyse avec les contributions de toutes les communes et toutes les variables d'équipement.


```{r bl-communes-ca-summary}
summary(ca_commune, nbelements = Inf)
```


### AFC de l'équipement des ménages par CSP de l'ensemble des individus actifs


On utilise la même méthode AFC mais cette fois entre équipement et catégories socio professionnelle (8 postes) de _l'ensemble des individus actifs de la BI_ (pas seulement les référents de ménages).
Pour cela, on joint sur la BI 2019 pour porter, les informations de logements seront _dupliquées_ pour tous ses occupants actifs.
On définit ici _actif_ comme un individu avec une CSP autre que _retraités_ (7) et _autres personnes sans activité professionnelle_ (8).
On commence par charge la BI 2019.

```{r bi-load-join, cache=TRUE}
# on va regrouper les communautés en 5 classes, correspondant à celles
# figurant au titre iv) de l'article 1 de l'arêté du 10/09/21 relatif à la diffusion du RP 2019

map_reth <- function(val) {
  case_when(
    val == "1" ~ "Kanake",
    val == "2" | val == "C" ~ "Européenne/Calédonienne",
    val == "7" ~ "Wallisienne/Futunienne",
    val == "M" ~ "Métis",
    TRUE ~ "Autre"
  )
}

bi19_r <- read_csv2("./src-rp/BI2019.csv") %>%
  filter(CS8 <= 6) %>%
  mutate(
    IDLOG = paste(NC, DIST, RADR, RLOG, sep = "-"),
    ETH = map_reth(RETH)
  )

# on oublie les erreurs et on joint
bl19_bi19 <- merge(bl19, bi19_r, by = "IDLOG", suffixes = c("_BL", "_BI")) %>% tibble()
```

On a gardé ainsi `r (nrow(bi19_r))` individus de la BI 2019, on transforme les données et on caclule l'AFC.

```{r bi-cs8-ca}
cs8m_labels <- c(
  "Agriculteurs exploitants",
  "Artisans, commerçants et chefs d'ent.",
  "Cadres et professions int. sup.",
  "Professions intermédiaires",
  "Employés",
  "Ouvriers",
  "Retraités",
  "Autres pers. sans activité pro."
)

# CS8 est la variable CSP dans la BI, CS8M celle dans la BL
df_cs8m_bi <- bl19_bi19 %>%
  select(CS8, ELEC, EAU, BATI, BAIN, WC, MAL, REFRI, CLIM, CHOS, TFIXE, INTER, VOIT, BATO, DEROU) %>%
  group_by(CS8) %>%
  summarise_all(
    sum
  ) %>%
  mutate(
    CS8 = factor(cs8m_labels[1:6])
  ) %>%
  column_to_rownames("CS8")

ca_csm_bi <- CA(df_cs8m_bi, graph = FALSE)
plot(ca_csm_bi)
```

On retrouve sensiblement les mêmes groupements de variables d'équipement sur un premier axe avec 93.1% de variance et un second marqué par la mobilité avec 3.8% d'inertie.

- le groupe  `CLIM`, `TFIXE`, `CHOS` et `INTER` est à proximité des CSP+, PI et artisans, qui tous les deux marquent le premier axe factoriel,
- le groupe `REFRI`, `ELEC`, `BAIN`, `MAL`, `WC` et `EAU` est proche du vers le profil moyen,
- `BATO` est un marqueur très fort des deux axes, `DEROU` aussi, `VOIT` moins.


```{r bi-cs8}
df_cs8m_bi
```

### AFC de l'équipement des ménages par niveau de diplôme de l'ensemble des individus actifs

Cette fois-ci on fait l'analyse par catégorie de diplômes des individus de la BI, avec une allure assez semblable au final constitué des mêmes groupes de variables.


```{r bi-diplm-ca}
diplm_labels <- c("Aucun", "CEP", "BEPC", "CAP/BEP", "Bac général", "Bac tech./pro.", "Bac+2/+3", "Bac+5/+8")

# DIPLR est la variable de diplôme dans la BI, DIPLM celle dans la BL
df_diplm_bi <- bl19_bi19 %>%
  select(DIPLR, ELEC, EAU, BATI, BAIN, WC, MAL, REFRI, CLIM, CHOS, TFIXE, INTER, VOIT, BATO, DEROU) %>%
  group_by(DIPLR) %>%
  summarise_all(
    sum
  ) %>%
  mutate(
    DIPLR = factor(diplm_labels)
  ) %>%
  column_to_rownames("DIPLR")

ca_diplm_bi <- CA(df_diplm_bi, graph = FALSE)
plot(ca_diplm_bi)
```

On voit que la représentation est franche, avec

- une premier axe qui capture 98.2% de la variance,
- les diplômes **sont parfaitement ordonnés selon la durée des études**  sur le premier axe :
  - Aucun diplôme et CEP;
  - BEPC et CAP/BEP;
  - Bacs technologiques ou professionnel puis les bacs généraux;
  - Bac+2/+3 et Bac+5/+8
- on retrouve les groupements similaires d'équipements,
- et également un poids important de la mobilité, sauf voiture.

```{r bi-diplm}
df_diplm_bi
```

### AFC de l'équipement des ménages par ethnie de l'ensemble des individus actifs

Cette fois enfin on fait l'analyse par groupe ethnique des individus de la BI et on s'abstiendra de toute autre commentaire.

```{r bi-eth-ca}
# DIPLR est la variable de diplôme dans la BI, DIPLM celle dans la BL
df_eth_bi <- bl19_bi19 %>%
  select(ETH, ELEC, EAU, BATI, BAIN, WC, MAL, REFRI, CLIM, CHOS, TFIXE, INTER, VOIT, BATO, DEROU) %>%
  group_by(ETH) %>%
  summarise_all(
    sum
  ) %>%
  column_to_rownames("ETH")

df_eth_bi <- CA(df_eth_bi, graph = FALSE)
plot(df_eth_bi)
```


```{r bi-eth}
summary(df_eth_bi, nbelements = Inf)
```


## Distribution et évolution du NEM

### Par province

On représente les variations du NEM100 par province sur chacune des années de recensement avec une représentation _violin plot_ qui permet de comparer les distributions des valeurs entre classes. On va comparer les profils sur chacun des 3 RP.
On commence par fusionner tous les BL avec une nouvelle colonne d'années puis on trace un _violin plot_ pour chaque province et chaque année.

```{r bl-prov-violin}
bl_merged <- rbind(
  bl09 %>% mutate(ANNEE = "2009"),
  bl14 %>% mutate(ANNEE = "2014"),
  bl19 %>% mutate(ANNEE = "2019")
)

ggplot(bl_merged, aes(x = PROV, y = NEM100, fill = ANNEE)) +
  ggtitle("Variations du NEM100 par province en 2009, 2014 et 2019") +
  xlab("Province") +
  scale_fill_brewer(palette = "Pastel2") +
  geom_violin()
```

On constate une tendance à **l'élévation du NEM dans la province nord et celle des îles** et à **la réduction de l'écart-type au sein de toutes les provinces**, correspondant à un ré-équilibrage des provinces et une réduction des inégalités.
Ceci est vérifié par les valeurs numériques ci-après.
On remarque en particulier _que l'élévation du NEM et la réduction de l'écart-type_ sont **très marqué entre 2009 et 2014** mais **moins entre 2014 et 2019**.
On rappelle que la moyenne NC du NEM100 a été recentrée sur la valeur 100. L'écart-type général étant respectivement de 30.6, 24.2 et 23.5 en 2009, 2014 et 2019.


```{r bl-prov-violin-numbers}
bl_merged %>%
  select(PROV, NEM100, ANNEE) %>%
  group_by(PROV, ANNEE) %>%
  summarise_all(list(mean = mean, sd = sd)) %>%
  pivot_wider(names_from = ANNEE, values_from = c(mean, sd))
```

### Par commune

On va faire la même représentation cette fois-ci sur le sous-ensemble des neuf communes d'intérêt du projet, à savoir (variable `TYPE` de `src-communes/communes.csv`) :

- les communes _métallurgiques_, à proximité des usines : Koné (11), Pouembout (25), Poya (27), Voh (31). Mont Dore (17) est aussi une commune identifiée mais exclue ici car dans le GN,
- les communes _minières_, à proximité des mines : Houailou (08), Yaté (32),
- les communes _témoins_, à l'écart des exploitations minières : Hienghène (07) et Lifou (14).

On commence par charger les trois BL que l'on joint avec les communes.

```{r append-bl-communes}
bl09_comm <- bl09 %>%
  merge(communes_csv, by.x = "NC", by.y = 0) %>%
  filter(!is.na(TYPE)) %>%
  select(NC, IRISUNC, NEM100, NOM_COMMUNE, TYPE)
bl09_comm$ANNEE <- "2009"

bl14_comm <- bl14 %>%
  merge(communes_csv, by.x = "NC", by.y = 0) %>%
  filter(!is.na(TYPE)) %>%
  select(NC, IRISUNC, NEM100, NOM_COMMUNE, TYPE)
bl14_comm$ANNEE <- "2014"

bl19_comm <- bl19 %>%
  merge(communes_csv, by.x = "NC", by.y = 0) %>%
  filter(!is.na(TYPE)) %>%
  select(NC, IRISUNC, NEM100, NOM_COMMUNE, TYPE)
bl19_comm$ANNEE <- "2019"

bl_comm <- bind_rows(bl09_comm, bl14_comm, bl19_comm)
```

Ensuite, on représente l'évolution de la distribution du `NEM100` en 2009, 2014 et 2019 avec la même représentation que pour les provinces.

```{r bl-communes-violin}
ggplot(bl_comm, aes(x = NOM_COMMUNE, y = NEM100, fill = ANNEE)) +
  ggtitle("Variations du NEM100 par commune") +
  xlab("Commune") +
  scale_fill_brewer(palette = "Pastel2") +
  geom_violin()
```

L'allure générale est encore à la réduction des inégalités, mais au niveau des communes, on constate certains variations opposées, en particulier sur Yaté.
La variation entre 2009 et 2019 est calculée en % pour la moyenne du NEM100 et en valeur absolue pour l'écart type.
Les valeurs numériques sont données ci-après.

```{r bl-comm-violin-numbers}
bl_comm %>%
  select(NOM_COMMUNE, NEM100, ANNEE) %>%
  group_by(NOM_COMMUNE, ANNEE) %>%
  summarise_all(list(mean = mean, sd = sd)) %>%
  pivot_wider(names_from = ANNEE, values_from = c(mean, sd)) %>%
  mutate(
    diff_pc_mean_2019_2009 = 100 * (mean_2019 / mean_2009 - 1),
    diff_abs_sd_2019_2009 = sd_2019 - sd_2009
  )
```


### Infra communes sur VKPP en 2019

Enfin, on représente la distribution du NEM100 sur les IRIS de VKPP.
On ajoute sur cette représentation moyenne (trait) et mediane (point).

```{r bl-vkpp-violin-2019}
# Voh (31), Koné (11), Pouembout (25), Poya (27)
vkpp_communes <- c("31", "11", "25", "27")

bl19_iris_com <- bl19 %>%
  merge(y = communes_csv, by.x = "NC", by.y = 0) %>%
  filter(NC %in% vkpp_communes) %>%
  merge(y = iris_csv, by.x = "IRISUNC", by.y = "IRIS")

ggplot(bl19_iris_com, aes(x = paste(IRISUNC, LIB_IRIS), y = NEM100, fill = NOM_COMMUNE)) +
  ggtitle("Variations du NEM100 par IRIS de VKPP en 2019 ") +
  xlab("IRIS VKPP") +
  scale_fill_brewer(palette = "Pastel2") +
  geom_violin() +
  stat_summary(fun = "mean", geom = "crossbar", width = 0.5, color = "grey", alpha = 0.8) +
  stat_summary(fun = "median", geom = "point", color = "grey", alpha = 0.8)
```

Les valeurs numériques sont données ci-après.

```{r bl-vkpp-violin-2019-numbers}
bl19_iris_com %>%
  select(NOM_COMMUNE, IRISUNC, LIB_IRIS, NEM100) %>%
  group_by(NOM_COMMUNE, IRISUNC, LIB_IRIS) %>%
  summarise_all(list(mean = mean, sd = sd)) %>%
  arrange(IRISUNC)
```

On constate une  **importante variation intra-communale** qui ne saurait être expliquée par la distance à la mine ou à l'usine, mais plutôt par leur homogénéité sociale.

## Représentations spatiales du NEM

On charge le shapefile des IRIS pour pouvoir générer des cartes et on joint la définition géographique au NEM via les codes des IRIS.
On étoffe le jeu de données avec quelques indicateurs synthétiques par IRIS :

- `COUNT_DIFF_0919` :  pourcentage relatif d'évolution 2009-2019 du nombre de logements,
- `NEM100_MEAN_PC_DIFF_0919` : pourcentage relatif d'évolution 2009-2019 de la moyenne du NEM base 100,
- `NEM100_SD_ABS_DIFF_0919` : évolution en valeur absolue 2009-2019 de _l'écart-type_ du NEM base 100,
- `NEM100_SD_ABS_DIFF_0914` : idem entre 2009 et 2014,
- `NEM100_SD_ABS_DIFF_1419` : idem entre 2014 et 2019.

On rappelle qu'on ne compte _que les résidences principales_ de la BL.

```{r nem-compute-iris}
iris <- st_read("src-iris/iris0914unc.shp") %>%
  select(COMM, CODE_IRIS, LIB_IRIS) %>%
  merge(y = nem_iris, by.x = "CODE_IRIS", by.y = "IRISUNC", all.x = TRUE) %>%
  merge(y = communes_csv, by.x = "COMM", by.y = 0) %>%
  mutate(
    COUNT_DIFF_0919 = 100 * ((COUNT_19 / COUNT_09) - 1),
    NEM100_MEAN_PC_DIFF_0919 = 100 * ((NEM100_MEAN_19 / NEM100_MEAN_09) - 1),
    NEM100_SD_ABS_DIFF_0919 = NEM100_SD_19 - NEM100_SD_09,
    NEM100_SD_ABS_DIFF_0914 = NEM100_SD_14 - NEM100_SD_09,
    NEM100_SD_ABS_DIFF_1419 = NEM100_SD_19 - NEM100_SD_14,
  )
```

Globalement, il y a eu une évolution `r 100 * (nrow(bl19) / nrow(bl09) - 1)`% du nombre de résidences principales en NC qui passe de `r nrow(bl09)` en 2009 à `r nrow(bl19)` en 2019.
Pour une meilleure lisibilité, on sépare la carte du Grand Nouméa (GN) du reste du territoire.

### Nombre de logements par IRIS

```{r bl-nb-iris-nc}
iris %>%
  select(COUNT_DIFF_0919) %>%
  plot(
    main = "Evolution (+%) du nombre de logements 2009-2019 NC hors GN",
    axes = FALSE,
    key.pos = 4,
    breaks = "jenks",
    nbreaks = 10
  )
```

En affichant les premiers résultats, on constate une forte évolution sur Koné (commune n°11), avec aussi la présence de Canala (n°04) et Houailou (n°08) à l'est.
Attention toutefois _aux effectifs qui peuvent être **très** faibles_ et qui expliquent certaines augmentation très importantes.
Ci-dessous, le top 20 des IRIS où le nombre de logements augmente le plus entre 2009 et 2019.
Si on prend en compte les IRIS du Grand Nouméa, on voit certaines évolutions dont Nouville en particulier.

```{r bl-nb-iris-table}
iris %>%
  arrange(desc(COUNT_DIFF_0919)) %>%
  select(CODE_IRIS, LIB_IRIS, NOM_COMMUNE, COUNT_DIFF_0919, COUNT_09, COUNT_19) %>%
  st_drop_geometry() %>%
  column_to_rownames("CODE_IRIS") %>%
  head(20)
```


### Evolution du NEM moyen par IRIS

On va maintenant s'intéresser à l'évolution de la moyenne du NEM base 100 par IRIS entre 2009 et 2019, ici on colorie selon 10 déciles du NEM100.

```{r nem-evol-iris-09-19}
plot(
  iris["NEM100_MEAN_PC_DIFF_0919"],
  main = "Evolution (+%) du NEM100 2009-2019 NC",
  axes = FALSE,
  key.pos = 4,
  breaks = "quantile",
  nbreaks = 10
)
```

```{r nem-evol-iris-09-19-summary}
iris %>%
  arrange(desc(NEM100_MEAN_PC_DIFF_0919)) %>%
  select(NOM_COMMUNE, LIB_IRIS, CODE_IRIS, NEM100_MEAN_PC_DIFF_0919, NEM100_MEAN_09, NEM100_MEAN_19) %>%
  st_drop_geometry() %>%
  column_to_rownames("CODE_IRIS") %>%
  head(20)
```

On constate, _avec cette échelle de couleur basée sur 10 quintiles_, une assez franche séparation Nord/Est versus Sud/Ouest

### Evolution de l'écart-type du NEM par IRIS

Maintenant, évaluons l'évolution de l'écart-type du NEM100 par IRIS entre 2009 et 2019. On classe les IRIS par la méthode `sd` en 10 classes.

```{r nem-evol-sd-iris-09-19}
plot(
  iris["NEM100_SD_ABS_DIFF_0919"],
  main = "Evolution (asbolue) de l'écart-type du NEM100 2009-2019 NC",
  axes = FALSE,
  key.pos = 4,
  breaks = "pretty",
  nbreaks = 5
)
```

L'écart type du NEM100 **a été considérable réduit sur l'ensemble du territoire**, sauf sur les IRIS ci-dessous.
On rappelle que écart-type NC du NEM100 passe de 30.6 en 2009 à 24.2 en 2014 puis 23.5 en 2019, soit un différence de -7.08 points entre 2009 et 2019.

```{r nem-evol-sd-iris-09-19-summary-pos}
iris %>%
  arrange(desc(NEM100_SD_ABS_DIFF_0919)) %>%
  select(NOM_COMMUNE, LIB_IRIS, CODE_IRIS, COUNT_19, NEM100_SD_ABS_DIFF_0919, NEM100_SD_09, NEM100_SD_19) %>%
  st_drop_geometry() %>%
  column_to_rownames("CODE_IRIS") %>%
  filter(NEM100_SD_ABS_DIFF_0919 > 0)
```

En comparaison, on garde ici les variations les plus importantes.

```{r nem-evol-sd-iris-09-19-summary-desc}
iris %>%
  arrange(NEM100_SD_ABS_DIFF_0919) %>%
  select(NOM_COMMUNE, LIB_IRIS, CODE_IRIS, COUNT_19, NEM100_SD_ABS_DIFF_0919, NEM100_SD_09, NEM100_SD_19) %>%
  st_drop_geometry() %>%
  column_to_rownames("CODE_IRIS") %>%
  head(10)
```


On proccède similairement pour la différence d'écrt type par IRIS entre 2009 et 2014.

```{r nem-evol-sd-iris-09-14}
plot(
  iris["NEM100_SD_ABS_DIFF_0914"],
  main = "Evolution (asbolue) de l'écart-type du NEM100 2009-2014 NC",
  axes = FALSE,
  key.pos = 4,
  breaks = "pretty",
  nbreaks = 5
)
```

On retrouve les IRIS où l'écart progresse :

```{r nem-evol-sd-iris-09-14-summary}
iris %>%
  arrange(desc(NEM100_SD_ABS_DIFF_0914)) %>%
  select(NOM_COMMUNE, LIB_IRIS, CODE_IRIS, COUNT_14, NEM100_SD_ABS_DIFF_0914, NEM100_SD_09, NEM100_SD_14) %>%
  st_drop_geometry() %>%
  column_to_rownames("CODE_IRIS") %>%
  filter(NEM100_SD_ABS_DIFF_0914 > 0)
```

Et de même entre 2014 et 2019. Ici, des écart substantiels apparaissent sur beaucoup plus de communes, **attention au changement des classes de couleurs**.


```{r nem-evol-sd-iris-14-19}
plot(
  iris["NEM100_SD_ABS_DIFF_1419"],
  main = "Evolution (absolue) de l'écart-type du NEM100 2014-2019 NC",
  axes = FALSE,
  key.pos = 4,
  breaks = "jenks",
  nbreaks = 5
)
```

On appréciera mieux avec la liste :

```{r nem-evol-sd-iris-14-19-summary}
iris %>%
  arrange(desc(NEM100_SD_ABS_DIFF_1419)) %>%
  select(NOM_COMMUNE, LIB_IRIS, CODE_IRIS, COUNT_14, NEM100_SD_ABS_DIFF_1419, NEM100_SD_14, NEM100_SD_19) %>%
  st_drop_geometry() %>%
  column_to_rownames("CODE_IRIS") %>%
  filter(NEM100_SD_ABS_DIFF_1419 > 0)
```

## Influence de la mine

Dans cette partie, nous allons comparer les contributions de différents co-facteurs au NEM100 et en particulier l'influence du facteur de durée de trajet à la mine.

### Variable `MINE`

La BI 2019 contient une variable `MINE` _l'individu travaille en lien avec la mine_.
Cette variable était aussi présente dans le BI 2014 de P. Rivoilant mais pas sur la version à disposition à l'ISEE.
La variable `MINE` concerne `r bi19_r  %>%  filter(MINE == 1)  %>% nrow()` actifs qui sont **tous** actifs dans le secteur _B - Industries extractives_ (variable `SECT21`).
Seuls 68 actifs de ce secteur en sont exclus, a priori, ils concernent le secteur carrière (caillasse, sables, schistes, etc.) _hors nickel_ comme la carrière de Dumbéa.


```{r mine-var}
bi19_r %>%
  mutate(MINE = replace_na(MINE, 0)) %>%
  group_by(MINE, SECT21) %>%
  count() %>%
  pivot_wider(id_cols = MINE, names_from = SECT21, values_from = n) %>%
  column_to_rownames("MINE")
```

```{r mine-var-not-sect21-b, include=FALSE}
# ici la liste détaillée de entreprise et fonctions des 68 concernés.
# non-inclus dans le rapport
bi19_r %>%
  mutate(MINE = replace_na(MINE, 0)) %>%
  filter(MINE == 0, SECT21 == "B") %>%
  select(ACTIV, NOMETAB, PROFSAL) %>%
  drop_na() %>%
  print(n = 68)
```

La variable `MINE` est inégalement répartie entre les ethnies, comme le montre le test du chi carré suivant où on donne sucessivement :

1. le tableau des effectifs,
2. le tableau des résidus,
3. le tableau des contributions, en % des résidus.

On constante :

- la sur-représentation des Kanaks (56.8 % de contribution au score),
- la sous-représentation des Européen/Calédoniens (31.0 % de contribution),
- peu de différence pour les autres ethnies.


```{r mine-var-chi2}
df_mine <- bi19_r %>%
  mutate(MINE = replace_na(MINE, 0)) %>%
  group_by(MINE, ETH) %>%
  count() %>%
  pivot_wider(id_cols = MINE, names_from = ETH, values_from = n, values_fill = 0) %>%
  column_to_rownames("MINE")

print(df_mine)
x2_mine <- chisq.test(df_mine)
print(x2_mine$residual)
contrib_pc <- 100 * x2_mine$residuals^2 / x2_mine$statistic
print(contrib_pc)
```

Sur l'ensemble de la NC, le % d'actifs dans la mine est de `r 100 * bi19_r %>% filter(MINE == 1) %>% nrow() / (bi19_r %>% nrow())`.
On calcule le % d'actifs dans le secteur nickel identifiés par la variable `MINE` de chaque commune que

```{r iris-var-mine-glob}
iris_mine <- bi19_r %>%
  group_by(IRISUNC) %>%
  summarise(
    POP_ACTIVE = n(),
    MINE_NB = sum(MINE == 1, na.rm = TRUE),
    MINE_PC = replace_na(100 * MINE_NB / POP_ACTIVE, 0)
  ) %>%
  right_join(y = iris, by = c("IRISUNC" = "CODE_IRIS")) %>%
  st_as_sf()

bi19_r %>%
  group_by(NC) %>%
  summarise(
    POP_ACTIVE = n(),
    MINE_NB = sum(MINE == 1, na.rm = TRUE),
    MINE_PC = replace_na(100 * MINE_NB / POP_ACTIVE, 0)
  ) %>%
  inner_join(rownames_to_column(communes_csv, "NC")) %>%
  select(NOM_COMMUNE, TYPE, POP_ACTIVE, MINE_NB, MINE_PC) %>%
  arrange(desc(MINE_PC)) %>%
  print(n = 33)
```

Ensuite, on représente spatialement les IRIS avec leur % d'actif dans le secteur nickel.

```{r iris-var-mine-plot}
iris_mine %>%
  select(MINE_PC) %>%
  plot(
    main = "% d'actifs dont l'employeur est dans le secteur nickel (variable MINE) par IRIS",
    axes = FALSE,
    key.pos = 4,
    breaks = "jenks",
    nbreaks = 3
  )
```


### Durée de trajet à la mine

Pour utiliser _la durée de trajet à la mine en minutes_ on charge _la matrice de desserte_.
Cette matrice fait correspondre à chaque IRIS la durée _médiane_ (sur les noeuds routiers contenus dans l'IRIS) pour attendre le site minier (mine ou usine) _le plus proche_ par la route, en roulant partour à la vitesse maximale autorisée.
Notons que la transformation des données est fait essentiellement en SQL, voir le fichier `src-desserte/desserte.sql` et que le calcul de la matrice elle même a été réalisé antérieurement.

On remarque que les IRIS de la province des îles, de l'île des Pins et de Belep disparaissent, car il n'y pas de routes vers les sites miniees, il reste ainsi 158 IRIS.
Comme précédement, on supprimera les communes du GN de l'étude.

On donne un exemple de la structure de la table de desserte avec 20 IRIS pris au hasard.

```{r load-desserte}
desserte <- read_csv("./src-desserte/duree_iris.csv") %>%
  select(code_iris, lib_iris, duree_usine, duree_centre) %>%
  mutate(
    duree_min = pmin(duree_usine, duree_centre)
  ) %>%
  column_to_rownames("code_iris")
desserte %>% sample_n(20)
```

#### Durée de trajet à l'usine

On represente la cartes des durée de trajet à l'usine métallurgique des IRIS.

```{r desserte-usine-plot}
iris %>%
  merge(desserte, by.x = "CODE_IRIS", by.y = 0) %>%
  select("duree_usine") %>%
  plot(
    main = "Durée médiane en minutes de trajet à l'usine la plus proche",
    axes = FALSE,
    key.pos = 4,
    breaks = seq(from = 0, to = 15 * ceiling(max(desserte$duree_usine) / 15), by = 15)
  )
```

On donne la liste des IRIS par durée décroissante d'accès à l'usine, pour les IRIS à plus d'une heure de trajet.
Le centre de la grande terre sur les deux côtés et le nord de la côte est sont les plus éloignés des usines.

```{r desserte-usine}
iris %>%
  merge(desserte, by.x = "CODE_IRIS", by.y = 0) %>%
  arrange(desc(duree_usine)) %>%
  column_to_rownames("CODE_IRIS") %>%
  select(LIB_IRIS, COMM, NOM_COMMUNE, TYPE, COUNT_19, duree_usine) %>%
  filter(duree_usine >= 60)
```

#### Durée de trajet à un centre minier

On fait la même chose pour la durée d'accès à un centre minier, _id est_ un site d'extraction minière.
On voit que **les communes les plus éloignées sont celles de la côte est de la province Nord** comme Hienghène, Touho, Pouébo ou Poindimié.

```{r desserte-centre-plot}
iris %>%
  merge(desserte, by.x = "CODE_IRIS", by.y = 0) %>%
  select("duree_centre") %>%
  plot(
    main = "Durée médiane en minutes de trajet au centre minier le plus proche",
    axes = FALSE,
    key.pos = 4,
    breaks = seq(from = 0, to = 15 * ceiling(max(desserte$duree_centre) / 15), by = 15)
  )
```

```{r desserte-centre}
iris %>%
  merge(desserte, by.x = "CODE_IRIS", by.y = 0) %>%
  arrange(desc(duree_centre)) %>%
  column_to_rownames("CODE_IRIS") %>%
  select(LIB_IRIS, COMM, NOM_COMMUNE, TYPE, COUNT_19, duree_centre) %>%
  filter(duree_centre >= 60)
```

#### Durée de trajet centre comme usine.

Enfin, on dessine la carte des durées de trajet vers les centres miniers **ou** les usines métallurgiques.
On remarque que le maillage des centre miniers est suffisament dense pour masquer celui des usines : la carte est sensiblement la même que la précédente.

```{r desserte-min-plot}
iris %>%
  merge(desserte, by.x = "CODE_IRIS", by.y = 0) %>%
  select("duree_min") %>%
  plot(
    main = "Durée médiane en minutes de trajet au centre minier ou l'usine métallurgique la plus proche",
    axes = FALSE,
    key.pos = 4,
    breaks = seq(from = 0, to = 15 * ceiling(max(desserte$duree_min) / 15), by = 15)
  )
```


### Préparation des données

On souhaite évaluer l'influence de la distance à la mine et la comparer à différent co-facteurs sur le NEM base 100.
Les co-facteurs d'intérêt sont mis sous forme catégorielle.
L'analyse va porter ici sur la BI 2019 jointe à la BL via l'identifiant de logement `IDLOG`.
On note qu'il y a `r bi19_r %>% filter(CS8 <=6, NC %notin% grand_noumea) %>% nrow()` actifs hors du GN dans la BI 2019.


```{r load-desserte-enrich}
mk_classes <- function(attr, width) {
  m <- width * floor(min(attr) / width)
  r <- paste0("[", str_pad(m, 3, pad = "0"), ",", str_pad(m + width, 3, pad = "0"), "[")
  f <- factor(paste0(
    "[",
    str_pad(width * floor(attr / width), 3, pad = "0"),
    ",",
    str_pad(width * (floor(attr / width) + 1), 3, pad = "0"),
    "["
  ))
  return(relevel(f, ref = r))
}

# on va créer quelques colonnes catégorielles correctement labélisées
bl19_desserte <- bl19_bi19 %>%
  filter(NC_BL %notin% grand_noumea) %>%
  mutate(MINE = replace_na(MINE, 0)) %>%
  merge(desserte, by.x = "IRISUNC_BL", by.y = 0) %>%
  mutate(
    # variable MINE
    MINE_ = factor(MINE, labels = c("non_minier", "minier")),
    # diplome regroupés
    DIPLR_ = relevel(factor(DIPLR, labels = diplm_labels), ref = 1),
    # CSP
    CS8_ = relevel(factor(CS8, labels = cs8m_labels[1:6]), ref = 1),
    # age révolu à la 10aine ~ groupe d'age décennal
    AGER_ = mk_classes(AGER, 10),
    # durée en 1/4 heures de trajets
    DUREE_USINE_QUART = mk_classes(duree_usine, 15),
    DUREE_CENTRE_QUART = mk_classes(duree_centre, 15),
    DUREE_QUART = mk_classes(duree_min, 15),
    # découpage en déciles du NEM100
    NEM100_DEC = paste0("N-", factor(I(ntile(NEM100, n = 10)))),
    ETH = relevel(factor(ETH), ref = "Kanake")
  ) %>%
  # select(NEM100, PROV_BL, DUREE_USINE_QUART, DIPLR_, AGER_, CS8_, MINE_, ETH) %>%
  tibble()

bl19_desserte$DUREE_USINE_QUART[1:32]
```

Après jointure avec les IRIS de desserte, on obtient `r nrow(bl19_desserte)` individus étudiés, répartis par commune comme suit.
On note que les îles hors de la Grande Terre ainsi que les communes du Grand Nouméa sont exclues (`NA`).

```{r load-desserte-commune}
bl19_desserte %>%
  count(NC_BL, MINE_) %>%
  right_join(rownames_to_column(communes_csv, "NC_BL")) %>%
  arrange(NC_BL) %>%
  select(NOM_COMMUNE, MINE_, n) %>%
  pivot_wider(id_cols = NOM_COMMUNE, names_from = MINE_, values_from = n) %>%
  select(-`NA`) %>%
  mutate(pc = 100 * minier / (non_minier + minier)) %>%
  print(n = 33)
```


### Durée de trajet et décile du NEM

Avec la représentation par analyse factorielle des correspondances sur les déciles du NEM base 100 on remarque :

- que l'axe des x est **parfaitement ordonné** selon les déciles du NEM100,
- que l'ordre des durées de trajet à l'usine est **bien moins représenté**,
- que le premier facteur catpure 92.3% de la variance.

```{r nem-desserte-ca}
df_nem_bl19_desserte <- bl19_desserte %>%
  group_by(NEM100_DEC, DUREE_QUART, .add = TRUE) %>%
  summarise(
    nb = n()
  ) %>%
  pivot_wider(names_from = DUREE_QUART, values_from = nb, values_fill = 0) %>%
  column_to_rownames("NEM100_DEC")

ca_bl19_desserte <- CA(df_nem_bl19_desserte, graph = FALSE)
plot(ca_bl19_desserte, title = "CA durée d'accès à la mine (1/4 heure) VS décile du NEM100")
```


```{r nem-desserte-ca-summary}
summary(ca_bl19_desserte)
```

### Durée de trajet et variable `MINE`

Comme précédement sur l'analyse du lien entre ethnie et `MINE`, on va fait un test statistique sur la durée de trajet en groupe de 15'.
On donne sucessivement :

- les effectifs observés,
- les résidus,
- les contributions (en % des résidus).

```{r mine-desserte-chi}
show_chi <- function(df) {
  # observés
  print(df)
  # chi 2 et résidus
  x2 <- chisq.test(df)
  print(x2$residual)
  # contribution
  con <- 100 * x2$residuals^2 / x2$statistic
  print(con)
  return(x2)
}

df_chi_mine_dur <- bl19_desserte %>%
  count(MINE_, DUREE_QUART) %>%
  arrange(DUREE_QUART) %>%
  pivot_wider(id_cols = MINE_, names_from = DUREE_QUART, values_from = n) %>%
  column_to_rownames("MINE_")

show_chi(df_chi_mine_dur)
```

On note bien une dépendance statistique entre `MINE_` et `DUREE_QUART`.
Elle apparait **difficile** à interpréter, mais suggère une **intéressante absence de linéarité** entre la distance à la mine et la variable `MINE` :

- les actifs de la mine sont **sur-représentés** à moins de 30' de trajets,
- puis chutent **brutalement** entre 45' et 60',
- ensuite actifs de la mine sont de mmoins en moins représentés avec la distance.

On va analyser cet _anneau_ de durée de trajet entre 30 et 60 minutes, par ethnie, CSP et diplome.

```{r mine-desserte-analyse-eth}
df_chi_duree_eth <- bl19_desserte %>%
  count(ETH, DUREE_QUART) %>%
  pivot_wider(id_cols = ETH, names_from = DUREE_QUART, values_from = n) %>%
  column_to_rownames("ETH") %>%
  mutate(across(everything(), coalesce, 0))

show_chi(df_chi_duree_eth)
```

On constate une sur-représentation des Européens/Calédoniens et une sous-représentation des Kanaks dans l'anneau `[45-60[`.

```{r mine-desserte-analyse-cs8}
df_chi_duree_cs8 <- bl19_desserte %>%
  count(CS8_, DUREE_QUART) %>%
  pivot_wider(id_cols = CS8_, names_from = DUREE_QUART, values_from = n) %>%
  column_to_rownames("CS8_") %>%
  mutate(across(everything(), coalesce, 0))

show_chi(df_chi_duree_cs8)
```

On constate une sur-représentation des cadre dans l'anneau `[15-30[`.

```{r mine-desserte-analyse-diplr}
df_chi_duree_diplr <- bl19_desserte %>%
  count(DIPLR_, DUREE_QUART) %>%
  pivot_wider(id_cols = DIPLR_, names_from = DUREE_QUART, values_from = n) %>%
  column_to_rownames("DIPLR_") %>%
  mutate(across(everything(), coalesce, 0))

show_chi(df_chi_duree_diplr)
```

## Modèles pour le NEM

Dans cette dernière partie on va _fit_ différent modèles au NEM base 100 pour comparer les facteurs d'analyse et d'isoler l'influence de la distance à la mine entre les facteurs.
Les facteurs d'intérêts pour cette analyse sont les suivants

```{r desserte-model-prep}
factors <- c("DIPLR_", "AGER_", "CS8_", "MINE_", "ETH")
durees <- c("DUREE_USINE_QUART", "DUREE_CENTRE_QUART", "DUREE_QUART")

nb_vals <- 0
for (att in factors) {
  vals <- bl19_desserte %>%
    pull(att) %>%
    unique() %>%
    length()
  nb_vals <- nb_vals + vals - 1
  print(paste(att, ":", vals, "valeurs"))
}
print(paste("Total :", nb_vals, "degrés de liberté"))

for (att in durees) {
  vals <- bl19_desserte %>%
    pull(att) %>%
    unique() %>%
    length()
  print(paste(att, ":", vals, "valeurs"))
}
```

Pour chaque modèle considéré, on calculera les indicateurs suivants entre le modèle null et celui proposé, où :

- `dev` est la différence de variation,
- `dof` est la différence du nombre de degrés de liberté (paramètres du modèle),
- `dev_by_dof` est la variation par degré de liberté,
- `dev_pc` est le pourcentage de varation capturé.


```{r desserte-model-prep-dof}
# fonction pour calculer les indicateurs composé des modèles
dof_info <- function(m) {
  r <- c()
  r["dev"] <- (m$null.deviance - m$deviance)
  r["dof"] <- (m$df.null - m$df.residual)
  r["dev_by_dof"] <- r["dev"] / r["dof"]
  r["dev_pc"] <- 100 * (m$null.deviance - m$deviance) / m$null.deviance
  return(r)
}

build_formula <- function(y, xs) {
  return(formula(paste(y, "~", paste(xs, collapse = " + "))))
}
```

### Pouvoir explicatif de la durée de trajet

On va comparer les trois durées de trajet calculées par IRIS (durée à l'usine métallurigque la plus proche, au centre minier le plus proche, minimum des deux) et avec les autres facteurs.
Pour cela, on va comparer un a un la variation capturée par chaque degré de liberté.

```{r desserte-model-factors}
attrs <- c(durees, factors)
res_attrs <- tibble(.rows = 4)
for (attr in attrs) {
  m <- glm(build_formula("NEM100", c(attr)), data = bl19_desserte)
  res_attrs[attr] <- dof_info(m)
}
res_attrs <- t(res_attrs)
colnames(res_attrs) <- c("dev", "dof", "dev_by_dof", "dev_pc")
print(res_attrs)
```

C'est la durée de trajet _à l'usine_ qui a le meilleur pouvoir explicatif pris en isolation parmi les trois durées.
Avec 10 classes, elle explique peu plus que le diplôme et que la CSP en 8 classes, mais **bien moins que la variable ethnique**

### Modèle d'indépendance des facteurs

On va considérer un premier modèle du `NEM100` avec les co-facteurs `DUREE_USINE_QUART`, `DIPLR_`, `CS8_` et `ETH`  **sans interactions**.
On supprime `AGER_` et  `MINE_` de l'analyse à ce stade.
Le modèle NULL a autant de degrés de liberté que le nombre d'invididus moins 1, soit ici `r nrow(bl19_desserte) - 1`.
Le modèle proposé va avoir autant de paramètres que de valeurs pour les facteurs choisis (moins 1 pour chaque facteur et plus 1 pour l'ordonnée à l'origine).

```{r desserte-model-m1}
smf <- setdiff(c(factors, "DUREE_USINE_QUART"), c("AGER_", "MINE_"))
m1 <- glm(build_formula("NEM100", smf), data = bl19_desserte)
summary(m1)
```

On affiche la distribution des résidus.

```{r desserte-model-m1-plot-qq}
plot(m1, which = 2)
```

On constante une influence globale **négative** du nombre de 1/4 d'heures de trajets à une usine sur le `NEM100` _quand elle est **statistiquement siginficative**_, **sauf pour les courtes durées**.
On constante que s'éloigner de la mine diminue globalement le niveau d'équipement, mais de façon non linéaire selon les 1/4 d'heures.
Le fait que les poids des 1/4 d'heures de trajets ne soient **pas décroissant** témoigne soit :

- d'une limite de ce facteur,
- d'une répartition hétérogène _en anneaux_, ce qui semble en cohérence avec l'analyse entre `MINE` et `DUREE_QUART` précédente (test du chi carré).

Les poids non ordonnés des durées de trajets est un phénomène attendu vue l'analyse précédente par AFC où les déciles du NEM étaient bien ordonnés mais pas les durées de trajet.
Les grandes durées de trajets correspondent de plus à des zones de la côte est, plutôt au nord.

En revanche, on constante l'influence positive substantielle **positive** sur le `NEM100` des facteurs suivants :

- du diplôme (`DIPLR_`) **croissant** selon la durée des études (référence _Aucun_),
- de la CSP (`CS8_`) croissant selon le niveau de qualification (référence _Agriculteurs exploitants_),
- de l'ethnie, en 3 groupes :
  - kanak, la catégorie de référence (coefficient 0)
  - métis, Wallis/Futuna et autres (dont asiatique), avec un coefficient entre 15.5 et 16.6,
  - européen ou calédonien, avec un coefficient de 23.8.

La croissance du poids de chaque facteur dans le modèle selon son ordre naturel démontre la qualité de la regression.
Par exemple, pour la variable `DIPLR_`, ne pas avoir de diplôme n'apporte aucun avantage sur le `NEM100` tandis que diposer d'un CEP en apporte 0.27, d'un BEPC 4.48 etc.
Travailler _directement_ dans le secteur minier a une influence **négative** sur le `NEM100`.

Si on les ajoute, on trouve aussi une influence positive de :

- du groupe d'âge décennal (`AGER_`)  aussi (référence `[10,20[`, soit entre 10 et 20 ans),
- du travail dans le secteur nickel (`MINE`) (référence `FALSE`),


```{r desserte-model-m1-dof}
dof_info(m1)
```

Une variation de `r dof_info(m1)["dev"]` avec `r dof_info(m1)["dof"]` soit `r dof_info(m1)["dev_by_dof"]` déviation par degré de liberté du modèle qui représente au total `r dof_info(m1)["dev_pc"]`% de la déviation.

On refait la même chose, mais cette fois avec un modèle **sans** prendre en compte la durée du trajet à la MINE :

```{r desserte-model-m2}
m2 <- glm(build_formula("NEM100", setdiff(factors, c("AGER_", "MINE_"))), data = bl19_desserte)
summary(m2)
```

```{r desserte-model-m2-dof}
dof_info(m2)
```

On fait un test d'analyse de la variance pour comparer les deux modèles

```{r desserte-model-m1-m2-anova}
anova(m2, m1, test = "Chisq")
```

### Modèle des facteurs pairs à pair

On reprend la même chose, mais cette fois-ci avec les paires de facteurs et leurs intéractions croisées

```{r desserte-model-pairs}
facts <- t(combn(c(factors, "DUREE_USINE_QUART"), 2))

for (i in seq_len(nrow(facts))) {
  print(facts[i,])
  f <- formula(paste("NEM100 ~ (", paste(facts[i,], collapse = " + "), ")^2"))
  m <- glm(f, data = bl19_desserte)
  print(dof_info(m))
}
```

On retient ici l'interaction entre ethnie et durée de trajet à l'usine et les autres facteurs indépendant.

```{r desserte-model-m3}
m3 <- glm("NEM100 ~ ETH * DUREE_USINE_QUART + CS8_ + DIPLR_ ", data = bl19_desserte)
print(summary(m3))
print(dof_info(m3))
```

On peut prendre un modèle plus riche, mais à un prix qui devient élevé en temps de calcul et en nombre de degrés de liberté : on touche les limites possibles avec ces facteurs.

```{r desserte-model-m4}
m4 <- glm("NEM100 ~ ETH*(DUREE_USINE_QUART + CS8_ + DIPLR_ + AGER_ + MINE_) ", data = bl19_desserte)
print(dof_info(m4))
```
